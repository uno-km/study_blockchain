// SPDX-License-Identifier: GPL-30
pragma solidity >= 0.7.0 < 0.9.0;
/*
   constructor =  생성자
   생성자는 변수의 값을 초기화 할때 주로 쓰인다.
   그러니 스마트 컨트랙이 처음 생성될때, 배포되거나 인스턴스화 될때 , 초기 변수의 파라미터 값을 받고 스마트컨트랙이 생성된다.
   예를 들어, 지난 8강에서 A라는 컨트랙을 인스턴스와 했다. 
   그런데 여기 A에는 생성자가 없이 인스턴스가 되었는데 , 만약 인스턴스화 할때 생성자가 있다면 A를 초기값을 정의해준다고 볼 수 있다.
   따라서 생성자는 어떤 컨트랙을 인스턴스화할때 초기값을 넣어주게 만드는 것이다.
*/
contract ClassA{
   
   string public name;
   uint256 public age;

   constructor(string memory inNm , uint256 inAge){
       name = inNm;
       age = inAge;
   }
    function setA(string memory inNm , uint256 inUint) public {
        name = inNm;
        age = inUint;
    }
}
contract ClassB{
    ClassA a = new ClassA("unoKim", 29);
    function getA() public view returns(string memory, uint256){
        return (a.name(), a.age());
    }
    function setA(string memory inNm , uint256 inUint) public {
        a.setA(inNm, inUint);
    }
}
/*
    추가로 여기서 함수를 배울때 좀 지나친 부분이있다.
    그것은 바로
    한 함수에서 리턴값을 2개 할수 있는 것이다.
    23번 줄을 보면 returns 에 여러개의 리턴값을 반환 하게 할수 있따.
    지금 이름과 나이를 (스트링과 유인트) 출력해야하니, 23번 줄에 타입 2개를 선언하고,
    하단의 return 밸류값에 괄호를 열어 해당 타입에 맞게 넣어주었다.
    이렇게 여러개를 솔리디티 내에서는 리턴할 수 있다.
*/
/*
    만약 컨스트럭터가 있는 컨트랙트만 배포 하고싶다면. 디플로이 후에 트랜색트 해서 해당 값만 욜케 바꾸기는 가능하다.
    그리고 다른 컨트랙트안에 또다른 컨트랙트를 인스턴스화 해서 접근하는 것보다 다른 방식을 사용해서 하는것이 
    훨씬 더 낳다.
    이유 : 인스턴스화 하면, 가스가 많이 소비가 된다. 그러니 다시말하면 B에서 A를 전부 가져오는 것이다 보니 가스소비가 더 많이 되는 것이다.
    그래서 이렇게 인스턴스화해서 가스가 많이 소비될 지라도, 만약에 스마트컨트랙이 가볍다면, 써도 무방할 수 있으나, 
    우리 자체의 스마트 컨트랙트가 자체적으로 무겁고, 이런 인스턴스화도 여러개를 써야한다면, 
    가스 소비량이 엄청 늘어날 것이다. 
    = 여기서 나오는 문제점 : 비용적인 측면보다, 블록마다(한블록당) 가스를 소비할 수 있는 양이 제한적이다.
    그말은 즉슨 : 우리가 제한하는 양을 초과해버리면, 우린 이더리움 자체 내에서 에러가 걸려서 스마트컨트랙을 아예 배포를 못하게 될 수도있다.
    이런식으로 가스 제한을 두는 이유 : 보안적인 측면에서 ,  한블록에서 가스를 제한해 둔다고 합니다.
    그래서 이런 경우에는 우린 클론팩토리 패턴이 있다.
    이것을 사용해서 가스 소비량을 획기적으로 줄일 수 있다.
    이 패턴에 대해서는 나중강의에 나온다.
*/